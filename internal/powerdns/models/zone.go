// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Zone Zone
//
// This represents an authoritative DNS Zone.
//
// swagger:model Zone
type Zone struct {

	// MAY be set. Its value is defined by local policy
	Account string `json:"account,omitempty"`

	//  Whether or not the zone will be rectified on data changes via the API
	APIRectify bool `json:"api_rectify,omitempty"`

	// Whether or not this zone is DNSSEC signed (inferred from presigned being true XOR presence of at least one cryptokey with active being true)
	Dnssec bool `json:"dnssec,omitempty"`

	// The SOA serial as seen in query responses. Calculated using the SOA-EDIT metadata, default-soa-edit and default-soa-edit-signed settings
	EditedSerial int64 `json:"edited_serial,omitempty"`

	// Opaque zone id (string), assigned by the server, should not be interpreted by the application. Guaranteed to be safe for embedding in URLs.
	ID string `json:"id,omitempty"`

	// Zone kind, one of “Native”, “Master”, “Slave”
	// Enum: [Native Master Slave]
	Kind string `json:"kind,omitempty"`

	// The id of the TSIG keys used for master operation in this zone
	MasterTsigKeyIds []string `json:"master_tsig_key_ids"`

	//  List of IP addresses configured as a master for this zone (“Slave” type zones only)
	Masters []string `json:"masters"`

	// Name of the zone (e.g. “example.com.”) MUST have a trailing dot
	Name string `json:"name,omitempty"`

	// MAY be sent in client bodies during creation, and MUST NOT be sent by the server. Simple list of strings of nameserver names, including the trailing dot. Not required for slave zones.
	Nameservers []string `json:"nameservers"`

	// The SOA serial notifications have been sent out for
	NotifiedSerial int64 `json:"notified_serial,omitempty"`

	// Whether or not the zone uses NSEC3 narrow
	Nsec3narrow bool `json:"nsec3narrow,omitempty"`

	// The NSEC3PARAM record
	Nsec3param string `json:"nsec3param,omitempty"`

	// Whether or not the zone is pre-signed
	Presigned bool `json:"presigned,omitempty"`

	// RRSets in this zone (for zones/{zone_id} endpoint only; omitted during GET on the .../zones list endpoint)
	Rrsets []*RRSet `json:"rrsets"`

	// The SOA serial number
	Serial int64 `json:"serial,omitempty"`

	// The id of the TSIG keys used for slave operation in this zone
	SlaveTsigKeyIds []string `json:"slave_tsig_key_ids"`

	// The SOA-EDIT metadata item
	SoaEdit string `json:"soa_edit,omitempty"`

	// The SOA-EDIT-API metadata item
	SoaEditAPI string `json:"soa_edit_api,omitempty"`

	// Set to “Zone”
	Type string `json:"type,omitempty"`

	// API endpoint for this zone
	URL string `json:"url,omitempty"`

	// MAY contain a BIND-style zone file when creating a zone
	Zone string `json:"zone,omitempty"`
}

// Validate validates this zone
func (m *Zone) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateKind(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRrsets(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var zoneTypeKindPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Native","Master","Slave"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		zoneTypeKindPropEnum = append(zoneTypeKindPropEnum, v)
	}
}

const (

	// ZoneKindNative captures enum value "Native"
	ZoneKindNative string = "Native"

	// ZoneKindMaster captures enum value "Master"
	ZoneKindMaster string = "Master"

	// ZoneKindSlave captures enum value "Slave"
	ZoneKindSlave string = "Slave"
)

// prop value enum
func (m *Zone) validateKindEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, zoneTypeKindPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Zone) validateKind(formats strfmt.Registry) error {
	if swag.IsZero(m.Kind) { // not required
		return nil
	}

	// value enum
	if err := m.validateKindEnum("kind", "body", m.Kind); err != nil {
		return err
	}

	return nil
}

func (m *Zone) validateRrsets(formats strfmt.Registry) error {
	if swag.IsZero(m.Rrsets) { // not required
		return nil
	}

	for i := 0; i < len(m.Rrsets); i++ {
		if swag.IsZero(m.Rrsets[i]) { // not required
			continue
		}

		if m.Rrsets[i] != nil {
			if err := m.Rrsets[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("rrsets" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("rrsets" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this zone based on the context it is used
func (m *Zone) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateRrsets(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Zone) contextValidateRrsets(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Rrsets); i++ {

		if m.Rrsets[i] != nil {
			if err := m.Rrsets[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("rrsets" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("rrsets" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *Zone) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Zone) UnmarshalBinary(b []byte) error {
	var res Zone
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
